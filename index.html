<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èº²é¿çƒå¤§æŒ‘æˆ° - ç‰¹æ€§è·¯å¾‘ç‰ˆ</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --player-color: #38bdf8;
            --text-color: #f8fafc;
            --danger-color: #f43f5e;
            --accent-color: #22c55e;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            max-height: 1000px;
            background-color: #1e293b;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            color: var(--text-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            align-items: center;
        }

        #level-display {
            background: rgba(34, 197, 94, 0.2);
            padding: 2px 12px;
            border-radius: 10px;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
        }

        #lives-display {
            color: var(--danger-color);
            font-size: 20px;
        }

        #status-effects {
            color: #fbbf24;
            font-size: 14px;
            margin-top: 5px;
            font-weight: bold;
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-color);
            background: rgba(15, 23, 42, 0.95);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid var(--player-color);
            width: 85%;
            box-sizing: border-box;
            z-index: 10;
        }

        button {
            background-color: var(--player-color);
            color: var(--bg-color);
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            margin-top: 20px;
            cursor: pointer;
            box-shadow: 0 4px 0 #0369a1;
            transition: transform 0.1s;
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #0369a1;
        }

        h1 { margin: 0 0 10px 0; font-size: 28px; color: var(--player-color); }
        #menu-desc { margin: 10px 0; font-size: 16px; line-height: 1.5; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="stats-row">
            <div id="level-display">é—œå¡ 1 / 10</div>
            <div id="lives-display">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div>
        </div>
        <div class="stats-row" style="margin-top: 5px;">
            <div id="score">åˆ†æ•¸: 0</div>
            <div id="highScore">æœ€é«˜: 0</div>
        </div>
        <div id="status-effects"></div>
    </div>

    <div id="menu">
        <h1 id="menu-title">ç‰¹æ€§è·¯å¾‘å¤§æŒ‘æˆ°</h1>
        <p id="menu-desc">ä¸åŒé¡è‰²çš„çƒæœ‰ä¸åŒçš„é£›è¡Œè¦å‰‡ï¼<br>å­å½ˆç›´ç·šè¡åˆºã€æ—‹é¢¨Så‹èµ°ä½...</p>
        <button id="start-btn">é–‹å§‹æŒ‘æˆ°</button>
    </div>
</div>

<script>
    // --- éŸ³æ•ˆå¼•æ“ (Web Audio API) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function playTone(freq, type, duration, volume = 0.1) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    const sounds = {
        hit: () => { playTone(150, 'sawtooth', 0.3, 0.1); },
        collect: () => { playTone(523, 'sine', 0.1, 0.1); setTimeout(()=>playTone(783, 'sine', 0.2, 0.1), 100); },
        levelup: () => { playTone(440, 'square', 0.1, 0.05); setTimeout(()=>playTone(659, 'square', 0.3, 0.05), 200); },
        gameover: () => { playTone(200, 'sawtooth', 0.5, 0.1); }
    };

    let bgmInterval;
    function startBGM() {
        if (bgmInterval) clearInterval(bgmInterval);
        const notes = [261, 293, 329, 349, 392, 349, 329, 293];
        let i = 0;
        bgmInterval = setInterval(() => {
            if (gameState === 'PLAYING') {
                playTone(notes[i], 'triangle', 0.4, 0.02); 
                i = (i + 1) % notes.length;
            }
        }, 500);
    }

    // --- éŠæˆ²é‚è¼¯ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('highScore');
    const livesElement = document.getElementById('lives-display');
    const levelElement = document.getElementById('level-display');
    const statusElement = document.getElementById('status-effects');
    const menu = document.getElementById('menu');
    const menuTitle = document.getElementById('menu-title');
    const menuDesc = document.getElementById('menu-desc');
    const startBtn = document.getElementById('start-btn');

    let gameState = 'START';
    let score = 0;
    let currentLevel = 1;
    const MAX_LEVEL = 10;
    const POINTS_PER_LEVEL = 200;
    let highScore = localStorage.getItem('dodgeProScore') || 0;
    let lastTime = 0;
    let animationId;
    let levelUpMsgTimer = 0;

    const TYPES = {
        NORMAL: { name: "ç¶“å…¸ç«çƒ", color: "#f97316", behavior: "linear" },
        BULLET: { name: "ç›´æ“Šå­å½ˆ", color: "#f43f5e", behavior: "straight" },
        ICE: { name: "å†°çˆ†å‡çµ", color: "#38bdf8", behavior: "pause_go" },
        TORNADO: { name: "å¹»å½±æ—‹é¢¨", color: "#a855f7", behavior: "sin_wave" },
        GHOST: { name: "å¹½éˆé–ƒçˆ", color: "#94a3b8", behavior: "jitter" },
        HEART: { name: "æ„›å¿ƒ", color: "#ec4899", label: "â¤ï¸" },
        BUFF: { name: "ç¸®å°è—¥æ°´", color: "#22c55e", label: "âœ¨" }
    };

    let lastTouchX = 0, lastTouchY = 0, isTouching = false;
    const player = {
        x: 0, y: 0, baseSize: 40, size: 40, lives: 5, maxLives: 5,
        invincibleTimer: 0, effectTimer: 0, currentEffect: null, animFrame: 0
    };

    let enemies = [];
    let enemySpawnTimer = 0;

    function resize() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        player.x = canvas.width / 2;
        player.y = canvas.height * 0.8;
        draw();
    }
    window.addEventListener('resize', resize);
    highScoreElement.innerText = `æœ€é«˜: ${highScore}`;

    function updateLivesUI() {
        let hearts = '';
        for(let i=0; i<player.maxLives; i++) hearts += i < player.lives ? 'â¤ï¸' : 'ğŸ–¤';
        livesElement.innerText = hearts;
    }

    // è§¸æ§èˆ‡æ»‘é¼ é‚è¼¯
    function handleStart(e) {
        if (gameState !== 'PLAYING') return;
        const t = e.touches ? e.touches[0] : e;
        lastTouchX = t.clientX; lastTouchY = t.clientY;
        isTouching = true;
    }
    function handleMove(e) {
        if (gameState !== 'PLAYING' || !isTouching) return;
        const t = e.touches ? e.touches[0] : e;
        player.x += (t.clientX - lastTouchX);
        player.y += (t.clientY - lastTouchY);
        lastTouchX = t.clientX; lastTouchY = t.clientY;
        player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
        player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
        if(e.cancelable) e.preventDefault();
    }
    canvas.addEventListener('touchstart', handleStart, {passive:false});
    canvas.addEventListener('touchmove', handleMove, {passive:false});
    canvas.addEventListener('touchend', () => isTouching = false);
    canvas.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', () => isTouching = false);

    startBtn.addEventListener('click', () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        startBGM();
        resetGame();
        gameState = 'PLAYING';
        menu.style.display = 'none';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    });

    function resetGame() {
        score = 0; currentLevel = 1; enemies = []; enemySpawnTimer = 0;
        player.lives = 5; player.size = player.baseSize; player.invincibleTimer = 0;
        updateLivesUI();
        scoreElement.innerText = `åˆ†æ•¸: 0`;
        levelElement.innerText = `é—œå¡ 1 / ${MAX_LEVEL}`;
    }

    function spawnEnemy() {
        const rand = Math.random();
        let type = TYPES.NORMAL;
        
        // éš¨é—œå¡æ¨é€²è§£é–ä¸åŒçƒç¨®
        if (rand < 0.07) type = TYPES.HEART;
        else if (rand < 0.11) type = TYPES.BUFF;
        else {
            const pool = [TYPES.NORMAL];
            if (currentLevel >= 2) pool.push(TYPES.BULLET);
            if (currentLevel >= 4) pool.push(TYPES.ICE);
            if (currentLevel >= 6) pool.push(TYPES.TORNADO);
            if (currentLevel >= 8) pool.push(TYPES.GHOST);
            type = pool[Math.floor(Math.random() * pool.length)];
        }

        let size = 32 + Math.random() * 8;
        let speed = 4 + (currentLevel * 0.5);
        
        // æ ¹æ“šé¡å‹å¾®èª¿å±¬æ€§
        if (type === TYPES.BULLET) { size = 20; speed *= 1.7; }
        if (type === TYPES.ICE) { size = 42; speed *= 0.8; }
        if (type === TYPES.TORNADO) { size = 35; }

        enemies.push({
            startX: Math.random() * (canvas.width - size),
            x: 0,
            y: -size,
            size: size,
            speed: speed,
            type: type,
            angle: 0,
            timeOffset: Math.random() * 1000,
            spawnTime: performance.now()
        });
        enemies[enemies.length-1].x = enemies[enemies.length-1].startX;
    }

    function update(dt) {
        if (player.invincibleTimer > 0) player.invincibleTimer -= dt;
        if (player.effectTimer > 0) {
            player.effectTimer -= dt;
            if (player.effectTimer <= 0) player.size = player.baseSize;
        }
        if (levelUpMsgTimer > 0) levelUpMsgTimer -= dt;
        player.animFrame += dt * 0.01;

        enemySpawnTimer += dt;
        const interval = Math.max(120, 900 - (currentLevel * 70));
        if (enemySpawnTimer > interval) {
            spawnEnemy();
            enemySpawnTimer = 0;
            score += 2;
            scoreElement.innerText = `åˆ†æ•¸: ${score}`;
            checkLevelUp();
        }

        const now = performance.now();
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dtScale = dt / 16.6;
            const elapsed = now - e.spawnTime;
            
            // --- ç‰¹æ€§è·¯å¾‘é‚è¼¯ ---
            switch(e.type.behavior) {
                case 'linear': // ç¶“å…¸ï¼šå—ä¸€é»é»é‡åŠ›å½±éŸ¿ï¼Œè¶Šæ‰è¶Šå¿«
                    e.y += (e.speed + (elapsed / 1000) * 2) * dtScale;
                    break;
                case 'straight': // å­å½ˆï¼šçµ•å°ç›´ç·šä¸”ç­‰é€Ÿè¡åˆº
                    e.y += e.speed * dtScale;
                    break;
                case 'sin_wave': // æ—‹é¢¨ï¼šå¤§å¹…åº¦Så‹æ™ƒå‹•
                    e.y += e.speed * 0.9 * dtScale;
                    e.x = e.startX + Math.sin((elapsed / 300) + e.timeOffset) * (canvas.width * 0.25);
                    break;
                case 'pause_go': // å†°çˆ†ï¼šå‰é€² -> åœé “ -> æš´è¡
                    const cycle = elapsed % 2000;
                    if (cycle < 1200) { // å‰é€²æœŸ
                        e.y += e.speed * 0.6 * dtScale;
                    } else if (cycle < 1600) { // å‡çµåœé “æœŸ
                        e.y += e.speed * 0.1 * dtScale;
                    } else { // ç ´å†°æš´è¡æœŸ
                        e.y += e.speed * 2.5 * dtScale;
                    }
                    break;
                case 'jitter': // å¹½éˆï¼šå¾®å°éœ‡å‹•ä¸¦é…åˆéš¨æ©Ÿå°è·³èº
                    e.y += e.speed * dtScale;
                    e.x = e.startX + (Math.random() - 0.5) * 15;
                    break;
                default:
                    e.y += e.speed * dtScale;
            }

            e.angle += 0.1 * dtScale;

            // ç¢°æ’æª¢æ¸¬
            const dx = player.x - (e.x + e.size/2);
            const dy = player.y - (e.y + e.size/2);
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < (player.size/2 + e.size/2) * 0.85) {
                handleCollision(e);
                enemies.splice(i, 1);
                continue;
            }
            if (e.y > canvas.height + 100) enemies.splice(i, 1);
        }
    }

    function handleCollision(e) {
        if (e.type === TYPES.HEART) {
            sounds.collect();
            if (player.lives < player.maxLives) player.lives++;
            else score += 150;
            updateLivesUI();
        } else if (e.type === TYPES.BUFF) {
            sounds.collect();
            player.size = player.baseSize * 0.6;
            player.effectTimer = 6000;
        } else {
            if (player.invincibleTimer <= 0) {
                player.lives--;
                sounds.hit();
                updateLivesUI();
                if (player.lives <= 0) gameOver();
                else player.invincibleTimer = 1500;
            }
        }
    }

    function checkLevelUp() {
        const nextLvl = Math.min(MAX_LEVEL, Math.floor(score / POINTS_PER_LEVEL) + 1);
        if (nextLvl > currentLevel) {
            currentLevel = nextLvl;
            sounds.levelup();
            levelUpMsgTimer = 2500;
            levelElement.innerText = `é—œå¡ ${currentLevel} / ${MAX_LEVEL}`;
        }
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        sounds.gameover();
        menuTitle.innerText = "æŒ‘æˆ°å¤±æ•—";
        menuDesc.innerHTML = `ä½ åœ¨ç¬¬ ${currentLevel} é—œé«”åŠ›é€æ”¯...<br>å¾—åˆ†: <span style="color:#f43f5e">${score}</span>`;
        startBtn.innerText = "å†æ¬¡å•Ÿå‹•";
        menu.style.display = 'block';
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('dodgeProScore', highScore);
            highScoreElement.innerText = `æœ€é«˜: ${highScore}`;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ç¹ªè£½æ ¼ç·šèƒŒæ™¯
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for(let i=0; i<canvas.width; i+=40) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
        }

        // ç©å®¶ (å°äºº)
        ctx.save();
        ctx.translate(player.x, player.y);
        if (player.invincibleTimer > 0 && Math.floor(performance.now()/80)%2) ctx.globalAlpha = 0.3;
        const s = player.size / 40;
        ctx.fillStyle = "#38bdf8";
        ctx.beginPath(); ctx.arc(0, -15*s, 7*s, 0, Math.PI*2); ctx.fill(); // é ­
        ctx.strokeStyle = "#38bdf8"; ctx.lineWidth = 4*s; ctx.lineCap="round";
        ctx.beginPath(); ctx.moveTo(0, -9*s); ctx.lineTo(0, 10*s); ctx.stroke(); // èº«
        const legY = 10*s + Math.sin(player.animFrame)*5*s;
        ctx.beginPath(); ctx.moveTo(0, 10*s); ctx.lineTo(-8*s, 22*s); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 10*s); ctx.lineTo(8*s, 22*s); ctx.stroke();
        ctx.restore();

        // æ•µäºº
        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x + e.size/2, e.y + e.size/2);
            const r = e.size / 2;
            const now = performance.now();

            if (e.type === TYPES.GHOST) {
                ctx.globalAlpha = 0.2 + Math.abs(Math.sin(now/150)) * 0.8;
            }

            if (e.type.label) {
                // é“å…·é¡
                ctx.shadowBlur = 10; ctx.shadowColor = e.type.color;
                ctx.fillStyle = e.type.color;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "white"; ctx.font = `${r}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
                ctx.fillText(e.type.label, 0, 0);
            } else {
                // çƒé¡è¦–è¦º
                const grad = ctx.createRadialGradient(-r*0.2,-r*0.2,0,0,0,r);
                grad.addColorStop(0, "white");
                grad.addColorStop(0.3, e.type.color);
                grad.addColorStop(1, "#000");
                ctx.fillStyle = grad;
                
                if (e.type === TYPES.BULLET) {
                    ctx.beginPath(); ctx.ellipse(0,0, r*0.7, r*1.3, 0, 0, Math.PI*2); ctx.fill();
                    // å™´å°„å°¾è·¡
                    ctx.fillStyle = "rgba(244, 63, 94, 0.3)";
                    ctx.beginPath(); ctx.moveTo(-r*0.5, -r); ctx.lineTo(0, -r*3); ctx.lineTo(r*0.5, -r); ctx.fill();
                } else if (e.type === TYPES.TORNADO) {
                    ctx.rotate(e.angle * 3);
                    ctx.strokeStyle = e.type.color; ctx.lineWidth = 2;
                    for(let j=0; j<4; j++) {
                        ctx.rotate(Math.PI/2);
                        ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(r, r, 0, r*1.2); ctx.stroke();
                    }
                    ctx.beginPath(); ctx.arc(0, 0, r*0.4, 0, Math.PI*2); ctx.fill();
                } else if (e.type === TYPES.ICE) {
                    ctx.beginPath();
                    for(let j=0; j<8; j++) {
                        ctx.rotate(Math.PI/4);
                        ctx.lineTo(r, 0); ctx.lineTo(r*0.4, r*0.2);
                    }
                    ctx.closePath(); ctx.fill();
                } else {
                    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                }
            }
            ctx.restore();
        });

        // å‡ç´šæç¤º
        if (levelUpMsgTimer > 0) {
            ctx.fillStyle = "rgba(34, 197, 94, "+ Math.min(1, levelUpMsgTimer/500) +")";
            ctx.font = "bold 28px Arial"; ctx.textAlign = "center";
            const currentTypeName = TYPES[Object.keys(TYPES)[(currentLevel-1) % 5]].name;
            ctx.fillText(`è§£é–ï¼š${currentTypeName}`, canvas.width/2, canvas.height/2);
        }
    }

    function gameLoop(time) {
        if (gameState !== 'PLAYING') return;
        update(time - lastTime);
        draw();
        lastTime = time;
        animationId = requestAnimationFrame(gameLoop);
    }

    resize();
</script>
</body>
</html>
