<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èº²é¿çƒå¤§æŒ‘æˆ° - ç‰¹æ€§è·¯å¾‘ç‰ˆ</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --player-color: #38bdf8;
            --text-color: #f8fafc;
            --danger-color: #f43f5e;
            --accent-color: #22c55e;
            --bullet-color: #64748b; /* éµç°è‰² */
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            max-height: 1000px;
            background-color: #1e293b;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            color: var(--text-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            align-items: center;
        }

        #level-display {
            background: rgba(34, 197, 94, 0.2);
            padding: 2px 12px;
            border-radius: 10px;
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
        }

        #lives-display {
            color: var(--danger-color);
            font-size: 20px;
        }

        #volume-control {
            position: absolute;
            top: 100px;
            right: 20px;
            pointer-events: auto;
            display: flex;
            align-items: center;
            background: rgba(15, 23, 42, 0.6);
            padding: 8px 12px;
            border-radius: 20px;
            gap: 10px;
            backdrop-filter: blur(4px);
            opacity: 0.6;
            transition: opacity 0.3s;
            z-index: 15;
        }
        
        #volume-control:hover {
            opacity: 1;
        }

        #volume-slider {
            width: 80px;
            cursor: pointer;
            accent-color: var(--player-color);
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-color);
            background: rgba(15, 23, 42, 0.95);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid var(--player-color);
            width: 85%;
            box-sizing: border-box;
            z-index: 10;
        }

        button {
            background-color: var(--player-color);
            color: var(--bg-color);
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            margin-top: 20px;
            cursor: pointer;
            box-shadow: 0 4px 0 #0369a1;
            transition: transform 0.1s;
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #0369a1;
        }

        h1 { margin: 0 0 10px 0; font-size: 28px; color: var(--player-color); }
        #menu-desc { margin: 10px 0; font-size: 16px; line-height: 1.5; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="stats-row">
            <div id="level-display">é—œå¡ 1 / 10</div>
            <div id="lives-display">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div>
        </div>
        <div class="stats-row" style="margin-top: 5px;">
            <div id="score">åˆ†æ•¸: 0</div>
            <div id="highScore">æœ€é«˜: 0</div>
        </div>
    </div>

    <div id="volume-control">
        <span id="volume-icon">ğŸ”Š</span>
        <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5">
    </div>

    <div id="menu">
        <h1 id="menu-title">ç‰¹æ€§è·¯å¾‘å¤§æŒ‘æˆ°</h1>
        <p id="menu-desc">ä¸åŒé¡è‰²çš„çƒæœ‰ä¸åŒçš„é£›è¡Œè¦å‰‡ï¼<br>å­å½ˆç›´ç·šè¡åˆºã€å¹½éˆé£„å¿½ä¸å®š...</p>
        <button id="start-btn">é–‹å§‹æŒ‘æˆ°</button>
    </div>
</div>

<script>
    // --- éŸ³æ•ˆå¼•æ“ ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    let globalVolume = 0.5;
    let bgmGainNode = null;
    let bgmOscillators = [];

    // å¼·åˆ¶åˆå§‹åŒ–ä¸¦æ¢å¾©éŸ³è¨Š
    async function initAudio() {
        if (!audioCtx) {
            audioCtx = new AudioContext();
        }
        if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
        }
    }

    const volumeSlider = document.getElementById('volume-slider');
    const volumeIcon = document.getElementById('volume-icon');
    volumeSlider.addEventListener('input', (e) => {
        globalVolume = parseFloat(e.target.value);
        volumeIcon.innerText = globalVolume === 0 ? "ğŸ”‡" : globalVolume < 0.5 ? "ğŸ”‰" : "ğŸ”Š";
        
        if (bgmGainNode && audioCtx) {
            bgmGainNode.gain.setTargetAtTime(globalVolume * 0.2, audioCtx.currentTime, 0.1);
        }
    });

    function playTone(freq, type, duration, volume = 0.1) {
        if (!audioCtx || audioCtx.state === 'suspended') return;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        const finalVolume = volume * globalVolume;
        gain.gain.setValueAtTime(finalVolume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function startBGM() {
        // ç¢ºä¿åœ¨é–‹å§‹æŒ‰éˆ•é»æ“Šæ™‚å•Ÿå‹•
        if (bgmOscillators.length > 0) return;

        bgmGainNode = audioCtx.createGain();
        bgmGainNode.gain.setValueAtTime(globalVolume * 0.2, audioCtx.currentTime);
        bgmGainNode.connect(audioCtx.destination);

        const createOsc = (freq, type) => {
            const osc = audioCtx.createOscillator();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.connect(bgmGainNode);
            osc.start();
            return osc;
        };

        // èƒŒæ™¯æ°›åœéŸ³ (A1, E2)
        bgmOscillators = [
            createOsc(55, 'sine'),
            createOsc(82.41, 'triangle')
        ];
    }

    const sounds = {
        hit: () => playTone(120, 'sawtooth', 0.3, 0.6),
        collect: () => { 
            playTone(523, 'sine', 0.1, 0.4); 
            setTimeout(()=>playTone(783, 'sine', 0.2, 0.4), 100); 
        },
        levelup: () => { 
            playTone(440, 'square', 0.1, 0.3); 
            setTimeout(()=>playTone(659, 'square', 0.3, 0.3), 200); 
        },
        gameover: () => playTone(80, 'sawtooth', 1.0, 0.8)
    };

    // --- éŠæˆ²é‚è¼¯ ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const highScoreElement = document.getElementById('highScore');
    const livesElement = document.getElementById('lives-display');
    const levelElement = document.getElementById('level-display');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('start-btn');

    let gameState = 'START';
    let score = 0;
    let currentLevel = 1;
    const MAX_LEVEL = 10;
    const POINTS_PER_LEVEL = 200;
    let highScore = localStorage.getItem('dodgeProScore') || 0;
    let lastTime = 0;
    let levelUpMsgTimer = 0;

    const TYPES = {
        NORMAL: { name: "ç¶“å…¸ç«çƒ", color: "#f97316", behavior: "linear" },
        BULLET: { name: "é«˜é€Ÿå­å½ˆ", color: "#64748b", behavior: "straight" }, // éµç°è‰²
        ICE: { name: "å†°çˆ†å‡çµ", color: "#38bdf8", behavior: "pause_go" },
        TORNADO: { name: "å¹»å½±æ—‹é¢¨", color: "#a855f7", behavior: "sin_wave" },
        GHOST: { name: "å¹½éˆé–ƒçˆ", color: "#cbd5e1", behavior: "jitter" },
        HEART: { name: "æ„›å¿ƒ", color: "#ec4899", label: "â¤ï¸" },
        BUFF: { name: "ç¸®å°è—¥æ°´", color: "#22c55e", label: "âœ¨" }
    };

    let isTouching = false;
    let lastTouchX = 0, lastTouchY = 0;
    const player = {
        x: 0, y: 0, baseSize: 40, size: 40, lives: 5, maxLives: 5,
        invincibleTimer: 0, effectTimer: 0, animFrame: 0
    };

    let enemies = [];
    let enemySpawnTimer = 0;

    function resize() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        player.x = canvas.width / 2;
        player.y = canvas.height * 0.8;
    }
    window.addEventListener('resize', resize);
    resize();
    highScoreElement.innerText = `æœ€é«˜: ${highScore}`;

    function handleStart(e) {
        if (gameState !== 'PLAYING') return;
        if (e.target.closest('#volume-control')) return;
        initAudio();
        const t = e.touches ? e.touches[0] : e;
        lastTouchX = t.clientX; lastTouchY = t.clientY;
        isTouching = true;
    }
    function handleMove(e) {
        if (gameState !== 'PLAYING' || !isTouching) return;
        const t = e.touches ? e.touches[0] : e;
        player.x += (t.clientX - lastTouchX);
        player.y += (t.clientY - lastTouchY);
        lastTouchX = t.clientX; lastTouchY = t.clientY;
        player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
        player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
        if(e.cancelable) e.preventDefault();
    }
    canvas.addEventListener('touchstart', handleStart, {passive:false});
    canvas.addEventListener('touchmove', handleMove, {passive:false});
    canvas.addEventListener('touchend', () => isTouching = false);
    canvas.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', () => isTouching = false);

    startBtn.addEventListener('click', async () => {
        await initAudio(); // ç•°æ­¥åˆå§‹åŒ–éŸ³è¨Š
        startBGM(); // å•Ÿå‹•èƒŒæ™¯éŸ³
        resetGame();
        gameState = 'PLAYING';
        menu.style.display = 'none';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    });

    function resetGame() {
        score = 0; currentLevel = 1; enemies = []; enemySpawnTimer = 0;
        player.lives = 5; player.size = player.baseSize; player.invincibleTimer = 0;
        updateLivesUI();
        scoreElement.innerText = `åˆ†æ•¸: 0`;
        levelElement.innerText = `é—œå¡ 1 / ${MAX_LEVEL}`;
    }

    function updateLivesUI() {
        let hearts = '';
        for(let i=0; i<player.maxLives; i++) hearts += i < player.lives ? 'â¤ï¸' : 'ğŸ–¤';
        livesElement.innerText = hearts;
    }

    function spawnEnemy() {
        const rand = Math.random();
        let type = TYPES.NORMAL;
        if (rand < 0.06) type = TYPES.HEART;
        else if (rand < 0.10) type = TYPES.BUFF;
        else {
            const pool = [TYPES.NORMAL];
            if (currentLevel >= 2) pool.push(TYPES.BULLET);
            if (currentLevel >= 4) pool.push(TYPES.ICE);
            if (currentLevel >= 6) pool.push(TYPES.TORNADO);
            if (currentLevel >= 8) pool.push(TYPES.GHOST);
            type = pool[Math.floor(Math.random() * pool.length)];
        }

        let size = 34 + Math.random() * 6;
        let speed = 4 + (currentLevel * 0.45);
        if (type === TYPES.BULLET) { size = 22; speed *= 1.8; }
        if (type === TYPES.GHOST) { size = 38; speed *= 0.9; }

        enemies.push({
            startX: Math.random() * (canvas.width - size),
            x: 0, y: -size, size: size, speed: speed, type: type,
            angle: 0, timeOffset: Math.random() * 1000, spawnTime: performance.now()
        });
        enemies[enemies.length-1].x = enemies[enemies.length-1].startX;
    }

    function update(dt) {
        if (player.invincibleTimer > 0) player.invincibleTimer -= dt;
        if (player.effectTimer > 0) {
            player.effectTimer -= dt;
            if (player.effectTimer <= 0) player.size = player.baseSize;
        }
        if (levelUpMsgTimer > 0) levelUpMsgTimer -= dt;
        player.animFrame += dt * 0.01;

        enemySpawnTimer += dt;
        const interval = Math.max(130, 850 - (currentLevel * 60));
        if (enemySpawnTimer > interval) {
            spawnEnemy();
            enemySpawnTimer = 0;
            score += 2;
            scoreElement.innerText = `åˆ†æ•¸: ${score}`;
            checkLevelUp();
        }

        const now = performance.now();
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const dtScale = dt / 16.6;
            const elapsed = now - e.spawnTime;

            switch(e.type.behavior) {
                case 'linear': e.y += (e.speed + (elapsed / 1200)) * dtScale; break;
                case 'straight': e.y += e.speed * dtScale; break;
                case 'sin_wave': 
                    e.y += e.speed * 0.85 * dtScale;
                    e.x = e.startX + Math.sin((elapsed / 300) + e.timeOffset) * (canvas.width * 0.2);
                    break;
                case 'pause_go':
                    const cycle = elapsed % 1800;
                    if (cycle < 1000) e.y += e.speed * 0.5 * dtScale;
                    else if (cycle < 1400) e.y += e.speed * 0.1 * dtScale;
                    else e.y += e.speed * 2.8 * dtScale;
                    break;
                case 'jitter':
                    e.y += e.speed * dtScale;
                    e.x = e.startX + Math.sin(elapsed / 50) * 8;
                    break;
                default: e.y += e.speed * dtScale;
            }

            e.angle += 0.15 * dtScale;

            const dx = player.x - (e.x + e.size/2);
            const dy = player.y - (e.y + e.size/2);
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < (player.size/2 + e.size/2) * 0.8) {
                handleCollision(e);
                enemies.splice(i, 1);
                continue;
            }
            if (e.y > canvas.height + 100) enemies.splice(i, 1);
        }
    }

    function handleCollision(e) {
        if (e.type === TYPES.HEART) {
            sounds.collect();
            if (player.lives < player.maxLives) player.lives++;
            updateLivesUI();
        } else if (e.type === TYPES.BUFF) {
            sounds.collect();
            player.size = player.baseSize * 0.6;
            player.effectTimer = 6000;
        } else {
            if (player.invincibleTimer <= 0) {
                player.lives--;
                sounds.hit();
                updateLivesUI();
                if (player.lives <= 0) gameOver();
                else player.invincibleTimer = 1500;
            }
        }
    }

    function checkLevelUp() {
        const nextLvl = Math.min(MAX_LEVEL, Math.floor(score / POINTS_PER_LEVEL) + 1);
        if (nextLvl > currentLevel) {
            currentLevel = nextLvl;
            sounds.levelup();
            levelUpMsgTimer = 2500;
            levelElement.innerText = `é—œå¡ ${currentLevel} / ${MAX_LEVEL}`;
        }
    }

    function gameOver() {
        gameState = 'GAMEOVER';
        sounds.gameover();
        document.getElementById('menu-title').innerText = "æŒ‘æˆ°å¤±æ•—";
        document.getElementById('menu-desc').innerHTML = `å¾—åˆ†: <span style="color:#f43f5e">${score}</span><br>ä½ åœ¨ç¬¬ ${currentLevel} é—œå€’ä¸‹äº†`;
        startBtn.innerText = "å†æ¬¡å•Ÿå‹•";
        menu.style.display = 'block';
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('dodgeProScore', highScore);
            highScoreElement.innerText = `æœ€é«˜: ${highScore}`;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.translate(player.x, player.y);
        if (player.invincibleTimer > 0 && Math.floor(performance.now()/80)%2) ctx.globalAlpha = 0.3;
        const s = player.size / 40;
        ctx.strokeStyle = "#38bdf8"; ctx.fillStyle = "#38bdf8"; ctx.lineWidth = 4 * s; ctx.lineCap = "round";
        ctx.beginPath(); ctx.arc(0, -15 * s, 7 * s, 0, Math.PI * 2); ctx.fill(); 
        ctx.beginPath(); ctx.moveTo(0, -9 * s); ctx.lineTo(0, 10 * s); ctx.stroke(); 
        const armSwing = Math.sin(player.animFrame) * 10 * s;
        ctx.beginPath(); ctx.moveTo(0, -5 * s); ctx.lineTo(-12 * s, armSwing); ctx.stroke(); 
        ctx.beginPath(); ctx.moveTo(0, -5 * s); ctx.lineTo(12 * s, -armSwing); ctx.stroke(); 
        const legSwing = Math.sin(player.animFrame) * 8 * s;
        ctx.beginPath(); ctx.moveTo(0, 10 * s); ctx.lineTo(-8 * s, 22 * s + legSwing); ctx.stroke(); 
        ctx.beginPath(); ctx.moveTo(0, 10 * s); ctx.lineTo(8 * s, 22 * s - legSwing); ctx.stroke(); 
        ctx.restore();

        enemies.forEach(e => {
            ctx.save();
            ctx.translate(e.x + e.size/2, e.y + e.size/2);
            const r = e.size / 2;
            const now = performance.now();

            if (e.type === TYPES.BULLET) {
                ctx.rotate(Math.PI); 
                const fireY = r * 1.5 + Math.random() * 10;
                const gradFire = ctx.createLinearGradient(0, 0, 0, fireY);
                gradFire.addColorStop(0, "#475569"); // éµç°æ·±
                gradFire.addColorStop(1, "transparent");
                ctx.fillStyle = gradFire;
                ctx.beginPath(); ctx.moveTo(-r*0.6, r); ctx.lineTo(0, fireY); ctx.lineTo(r*0.6, r); ctx.fill();
                ctx.fillStyle = e.type.color;
                ctx.beginPath();
                ctx.moveTo(0, -r * 1.8);
                ctx.quadraticCurveTo(r, -r, r, r);
                ctx.lineTo(-r, r);
                ctx.quadraticCurveTo(-r, -r, 0, -r * 1.8);
                ctx.fill();
            } else if (e.type === TYPES.GHOST) {
                const alpha = 0.3 + Math.abs(Math.sin(now / 200)) * 0.5;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#cbd5e1";
                ctx.beginPath();
                ctx.arc(0, -r*0.2, r, Math.PI, 0);
                ctx.lineTo(r, r);
                for(let j=0; j<3; j++) {
                    const waveX = r - (j * (r*0.66)) - r*0.33;
                    const waveY = r + Math.sin(now/100 + j)*5;
                    ctx.quadraticCurveTo(waveX + r*0.3, waveY + 5, waveX - r*0.3, r);
                }
                ctx.lineTo(-r, r);
                ctx.closePath(); ctx.fill();
                ctx.globalAlpha = 1;
                ctx.fillStyle = "#1e293b";
                ctx.beginPath(); ctx.arc(-r*0.4, -r*0.2, r*0.15, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(r*0.4, -r*0.2, r*0.15, 0, Math.PI*2); ctx.fill();
            } else if (e.type === TYPES.ICE) {
                ctx.fillStyle = e.type.color;
                ctx.beginPath();
                for(let j=0; j<8; j++) {
                    ctx.rotate(Math.PI/4);
                    ctx.lineTo(r, 0); ctx.lineTo(r*0.4, r*0.2);
                }
                ctx.closePath(); ctx.fill();
            } else if (e.type === TYPES.TORNADO) {
                ctx.rotate(e.angle * 3);
                ctx.strokeStyle = e.type.color; ctx.lineWidth = 3;
                for(let j=0; j<4; j++) {
                    ctx.rotate(Math.PI/2);
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(r, r, 0, r*1.3); ctx.stroke();
                }
            } else if (e.type.label) {
                ctx.fillStyle = e.type.color;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "white"; ctx.font = `bold ${r}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
                ctx.fillText(e.type.label, 0, 2);
            } else {
                const grad = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.1, 0, 0, r);
                grad.addColorStop(0, "#ffedd5");
                grad.addColorStop(0.4, e.type.color);
                grad.addColorStop(1, "#7c2d12");
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        });

        if (levelUpMsgTimer > 0) {
            ctx.save();
            ctx.fillStyle = "rgba(34, 197, 94, "+ Math.min(1, levelUpMsgTimer/500) +")";
            ctx.font = "bold 24px Arial"; ctx.textAlign = "center";
            ctx.fillText(`è§£é–æ–°çƒç¨®ï¼š${TYPES[Object.keys(TYPES)[(currentLevel-1)%5]].name}`, canvas.width/2, canvas.height/2);
            ctx.restore();
        }
    }

    function gameLoop(time) {
        if (gameState !== 'PLAYING') return;
        update(time - lastTime);
        draw();
        lastTime = time;
        requestAnimationFrame(gameLoop);
    }
</script>
</body>
</html>
